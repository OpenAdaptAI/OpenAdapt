#!/usr/bin/env python3
"""Generate comprehensive screenshots for OpenAdapt documentation.

This script generates professional screenshots for:
1. Installation process and CLI examples
2. Viewer interfaces (capture, segmentation, benchmark)
3. Capture interface and recording process
4. Training dashboards
5. Episode segmentation results
6. Benchmark evaluation results

Each category gets multiple screenshots showing different states and features.
"""

from __future__ import annotations

import argparse
import json
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Callable, Optional

try:
    from playwright.sync_api import sync_playwright, Page, ViewportSize
except ImportError:
    print("ERROR: playwright is not installed")
    print("Install with: pip install playwright && playwright install chromium")
    sys.exit(1)


@dataclass
class ScreenshotConfig:
    """Configuration for a single screenshot scenario."""

    name: str
    description: str
    viewport_width: int = 1400
    viewport_height: int = 900
    full_page: bool = False
    interact: Optional[Callable] = None
    wait_after_load: int = 1000
    wait_after_interact: int = 500


class DocsScreenshotGenerator:
    """Generate screenshots for OpenAdapt documentation."""

    def __init__(self, output_dir: Path):
        """Initialize the screenshot generator.

        Args:
            output_dir: Directory to save screenshots
        """
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Paths to various components
        self.docs_root = Path(__file__).parent.parent
        self.repo_root = self.docs_root.parent

    def generate_cli_screenshots(self) -> list[Path]:
        """Generate screenshots of CLI examples.

        Returns:
            List of paths to generated screenshots
        """
        print("\n=== Generating CLI Screenshots ===\n")

        # Terminal screenshots with iTerm2 or Terminal.app
        # These would be generated by running actual commands and capturing

        scenarios = [
            {
                "name": "01_installation",
                "command": "pip install openadapt[all]",
                "description": "Installation command"
            },
            {
                "name": "02_capture_start",
                "command": "openadapt capture start --name my-task",
                "description": "Starting a capture"
            },
            {
                "name": "03_capture_list",
                "command": "openadapt capture list",
                "description": "Listing captures"
            },
            {
                "name": "04_train_start",
                "command": "openadapt train start --capture my-task --model qwen3vl-2b",
                "description": "Starting training"
            },
            {
                "name": "05_eval_run",
                "command": "openadapt eval run --checkpoint model.pt --benchmark waa",
                "description": "Running evaluation"
            },
        ]

        print("CLI screenshots would require terminal automation.")
        print("Suggested tools: iTerm2 automation, asciinema, or termtosvg")
        print("\nScenarios to capture:")
        for scenario in scenarios:
            print(f"  - {scenario['name']}: {scenario['description']}")
            print(f"    Command: {scenario['command']}")

        return []

    def generate_viewer_screenshots(self) -> list[Path]:
        """Generate screenshots of various viewer interfaces.

        Returns:
            List of paths to generated screenshots
        """
        print("\n=== Generating Viewer Screenshots ===\n")

        screenshots = []

        # Check for existing viewer HTML files
        viewer_locations = [
            self.repo_root / "openadapt-viewer",
            self.repo_root / "openadapt-ml",
            self.repo_root / "openadapt-capture",
        ]

        # Look for HTML viewer files
        viewer_files = []
        for location in viewer_locations:
            if location.exists():
                viewer_files.extend(location.glob("*viewer*.html"))
                viewer_files.extend(location.glob("**/dist/*.html"))

        if not viewer_files:
            print("No viewer HTML files found. Generate viewers first:")
            print("  cd ../openadapt-viewer")
            print("  uv run openadapt-viewer demo --output viewer.html")
            return []

        # Generate screenshots for each viewer
        with sync_playwright() as p:
            browser = p.chromium.launch()

            for viewer_file in viewer_files[:3]:  # Limit to first 3 for demo
                print(f"Capturing: {viewer_file.name}")

                scenarios = [
                    ScreenshotConfig(
                        name=f"{viewer_file.stem}_overview",
                        description=f"Overview of {viewer_file.stem}",
                        viewport_height=900,
                    ),
                    ScreenshotConfig(
                        name=f"{viewer_file.stem}_detail",
                        description=f"Detail view of {viewer_file.stem}",
                        viewport_height=1200,
                        full_page=True,
                    ),
                ]

                for scenario in scenarios:
                    try:
                        page = browser.new_page(
                            viewport={
                                "width": scenario.viewport_width,
                                "height": scenario.viewport_height,
                            }
                        )

                        page.goto(f"file://{viewer_file}")
                        page.wait_for_timeout(scenario.wait_after_load)

                        if scenario.interact:
                            scenario.interact(page)
                            page.wait_for_timeout(scenario.wait_after_interact)

                        screenshot_path = (
                            self.output_dir / f"{scenario.name}.png"
                        )
                        page.screenshot(
                            path=str(screenshot_path),
                            full_page=scenario.full_page,
                        )

                        screenshots.append(screenshot_path)
                        print(f"  ✓ Saved: {screenshot_path.name}")

                        page.close()

                    except Exception as e:
                        print(f"  ✗ Error capturing {scenario.name}: {e}")

            browser.close()

        return screenshots

    def generate_segmentation_screenshots(self) -> list[Path]:
        """Generate screenshots of episode segmentation viewer.

        Returns:
            List of paths to generated screenshots
        """
        print("\n=== Generating Episode Segmentation Screenshots ===\n")

        # Look for segmentation viewer
        segmentation_viewer = None
        search_paths = [
            self.repo_root / "openadapt-viewer" / "segmentation_viewer.html",
            self.repo_root / "openadapt-ml" / "segmentation_viewer.html",
        ]

        for path in search_paths:
            if path.exists():
                segmentation_viewer = path
                break

        if not segmentation_viewer:
            print("No segmentation viewer found. Generate it first:")
            print("  cd ../openadapt-viewer")
            print("  uv run python scripts/generate_segmentation_viewer.py --output segmentation_viewer.html")
            return []

        screenshots = []

        scenarios = [
            ScreenshotConfig(
                name="segmentation_overview",
                description="Episode library with thumbnails",
                viewport_height=900,
            ),
            ScreenshotConfig(
                name="segmentation_episode_detail",
                description="Selected episode with key frames",
                viewport_height=1200,
                full_page=True,
            ),
            ScreenshotConfig(
                name="segmentation_search",
                description="Search and filter functionality",
                viewport_height=900,
            ),
        ]

        with sync_playwright() as p:
            browser = p.chromium.launch()

            for scenario in scenarios:
                try:
                    page = browser.new_page(
                        viewport={
                            "width": scenario.viewport_width,
                            "height": scenario.viewport_height,
                        }
                    )

                    page.goto(f"file://{segmentation_viewer}")
                    page.wait_for_timeout(scenario.wait_after_load)

                    if scenario.interact:
                        scenario.interact(page)
                        page.wait_for_timeout(scenario.wait_after_interact)

                    screenshot_path = self.output_dir / f"{scenario.name}.png"
                    page.screenshot(
                        path=str(screenshot_path),
                        full_page=scenario.full_page,
                    )

                    screenshots.append(screenshot_path)
                    print(f"  ✓ Saved: {screenshot_path.name}")

                    page.close()

                except Exception as e:
                    print(f"  ✗ Error capturing {scenario.name}: {e}")

            browser.close()

        return screenshots

    def generate_architecture_diagrams(self) -> list[Path]:
        """Generate architecture diagram screenshots.

        Returns:
            List of paths to generated screenshots
        """
        print("\n=== Generating Architecture Diagrams ===\n")

        # Check if architecture page has mermaid diagrams
        architecture_md = self.docs_root / "architecture.md"

        if not architecture_md.exists():
            print("Architecture documentation not found")
            return []

        # Would need to render mermaid diagrams to PNG
        print("Architecture diagrams require mermaid rendering:")
        print("  Option 1: Use mermaid-cli (mmdc)")
        print("  Option 2: Use mkdocs with material theme")
        print("  Option 3: Use online mermaid renderer")

        return []

    def generate_all_screenshots(self, categories: list[str] = None) -> dict[str, list[Path]]:
        """Generate all screenshots or specific categories.

        Args:
            categories: List of categories to generate. If None, generates all.
                       Options: ['cli', 'viewers', 'segmentation', 'architecture']

        Returns:
            Dictionary mapping category names to lists of screenshot paths
        """
        all_categories = {
            "cli": self.generate_cli_screenshots,
            "viewers": self.generate_viewer_screenshots,
            "segmentation": self.generate_segmentation_screenshots,
            "architecture": self.generate_architecture_diagrams,
        }

        if categories is None:
            categories = list(all_categories.keys())

        results = {}
        for category in categories:
            if category in all_categories:
                results[category] = all_categories[category]()
            else:
                print(f"Warning: Unknown category '{category}'")

        return results

    def generate_metadata(self, screenshots: dict[str, list[Path]]) -> Path:
        """Generate metadata JSON file for all screenshots.

        Args:
            screenshots: Dictionary mapping categories to screenshot paths

        Returns:
            Path to generated metadata file
        """
        metadata = {
            "version": "1.0",
            "generated_by": "generate_docs_screenshots.py",
            "categories": {},
        }

        for category, paths in screenshots.items():
            metadata["categories"][category] = [
                {
                    "filename": p.name,
                    "path": str(p.relative_to(self.output_dir)),
                    "size_bytes": p.stat().st_size if p.exists() else 0,
                }
                for p in paths
            ]

        metadata_path = self.output_dir / "screenshots_metadata.json"
        with open(metadata_path, "w") as f:
            json.dump(metadata, f, indent=2)

        print(f"\n✓ Metadata saved: {metadata_path}")
        return metadata_path


def main():
    """Main entry point for screenshot generation."""
    parser = argparse.ArgumentParser(
        description="Generate comprehensive screenshots for OpenAdapt documentation"
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path(__file__).parent.parent / "assets" / "screenshots",
        help="Output directory for screenshots (default: docs/assets/screenshots)",
    )
    parser.add_argument(
        "--categories",
        nargs="+",
        choices=["cli", "viewers", "segmentation", "architecture"],
        help="Specific categories to generate (default: all)",
    )
    parser.add_argument(
        "--save-metadata",
        action="store_true",
        help="Generate metadata JSON file",
    )

    args = parser.parse_args()

    print("=" * 60)
    print("OpenAdapt Documentation Screenshot Generator")
    print("=" * 60)

    generator = DocsScreenshotGenerator(output_dir=args.output)

    screenshots = generator.generate_all_screenshots(categories=args.categories)

    # Print summary
    print("\n" + "=" * 60)
    print("Screenshot Generation Summary")
    print("=" * 60)

    total_screenshots = sum(len(paths) for paths in screenshots.values())
    print(f"\nGenerated {total_screenshots} screenshots across {len(screenshots)} categories:")

    for category, paths in screenshots.items():
        print(f"  {category}: {len(paths)} screenshots")

    if args.save_metadata:
        generator.generate_metadata(screenshots)

    print(f"\nScreenshots saved to: {args.output}")
    print("\nTo use in documentation:")
    print(f"  ![Description](assets/screenshots/filename.png)")


if __name__ == "__main__":
    main()
